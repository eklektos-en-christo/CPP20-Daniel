//
// Created by Εκλεκτός εν Χριστώ on 5/13/24.
//

#ifndef PRACTICE_COMPARABLESTRING_H
#define PRACTICE_COMPARABLESTRING_H

#include <iostream>
#include <string>
#include <utility>

class ComparableString
{
public:
    ComparableString(std::string  str) : m_str{std::move(str)}{}

    // default ordering for string is strong ordering, we want to compare the string by their
    // size, so weak ordering is being used
    // weak ordering - strings maybe equal in number of size but not absolutely equivalent
    std::weak_ordering operator<=>(const ComparableString& right) const
    {
        if (m_str.size() == right.m_str.size())
            return std::weak_ordering::equivalent;
        else if (m_str.size() < right.m_str.size())
            return std::weak_ordering::less;
        else
            return std::weak_ordering::greater;
    }

    // with non defaulted <=>, compiler wont generate ==, so implementing
    // != will also be generated by seeing the ==
    bool operator==(const ComparableString& right) const
    {
        return (m_str.size() == right.m_str.size());
    }

private:
    std::string m_str{};
};

#endif //PRACTICE_COMPARABLESTRING_H
