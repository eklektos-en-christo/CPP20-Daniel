//
// Created by Εκλεκτός εν Χριστώ on 5/8/24.
//

#ifndef PRACTICE_POINT_H
#define PRACTICE_POINT_H

#include <iostream>

class Point
{
public:
    Point() = default;
    Point(double x, double y) : m_x{x}, m_y{y}
    {
    }
    Point(double x_y) : Point{x_y, x_y}     // for implicit conversions
    {
    }
    ~Point() = default;

    // overloaded logical operators
    // first operand is implicit object
    // 2nd is right side operand
    // bool - result can be used for other purposes
    // const - functions don't modify the Point
    /*bool operator>(const Point& other) const;
    bool operator<(const Point& other) const;
    bool operator>=(const Point& other) const;
    bool operator<=(const Point& other) const;
    bool operator==(const Point& other) const;
    bool operator!=(const Point& other) const;*/

    friend std::ostream& operator<<(std::ostream& os, const Point& p)
    {
        os << "Point: [" << p.m_x << ", " << p.m_y << ", " << p.length() << ']';
        return os;
    }

    // logical operator overloads as non member functions
    /*friend bool operator>(const Point& left, const Point& right);*/
    /*friend bool operator<(const Point& left, const Point& right);*/
    /*friend bool operator>=(const Point& left, const Point& right);
    friend bool operator<=(const Point& left, const Point& right);*/
    /*friend bool operator==(const Point& left, const Point& right);*/
    /*friend bool operator!=(const Point& left, const Point& right);*/

    // compiler won't generate == when <=> is non defaulted, so implementing
    // != will be generated by seeing this operator==
    bool operator==(const Point& right) const
    {
        return length() == right.length();
    }

    // returning partial ordering for double - there is possiblity of incomparable values
    // non defaulted custom <=> operator
    // return the values according to the relationship between both operands
    // generates 4 logical operators
    std::partial_ordering operator<=>(const Point& right) const
    {
        if (length() > right.length())
            return std::partial_ordering::greater;
        else if (length() < right.length())
            return std::partial_ordering::less;
        else if (length() == right.length())
            return std::partial_ordering::equivalent;
        else
            return std::partial_ordering::unordered;
    }

private:
    double m_x{};
    double m_y{};

    // helps in comparison
    double length() const;
};

/*
inline bool operator>(const Point& left, const Point& right)
{
    return left.length() > right.length();
}*/

/*
inline bool operator<(const Point& left, const Point& right)
{
    return left.length() < right.length();
}*/

/*
inline bool operator>=(const Point& left, const Point& right)
{
    return left.length() >= right.length();
}

inline bool operator<=(const Point& left, const Point& right)
{
    return left.length() <= right.length();
}*/

/*inline bool operator==(const Point& left, const Point& right)
{
    return left.length() == right.length();
}*/

/*
inline bool operator!=(const Point& left, const Point& right)
{
    return left.length() != right.length();
}*/

#endif //PRACTICE_POINT_H
